### 1. Array.flat

```js
const arr = [1, [2, [3, [4, 5]]], 6];

// 存在问题，修改了原数据
Array.prototype.flat = function(){
  const args = Array.from(this);
  const argsStr = JSON.stringify(args);
  return argsStr.replace(/\[|\]/g, '').split(',');
};

Array.prototype.flat = function(){
  return this.reduce(function(pre, cur) {
    return pre.concat(
      Array.isArray(cur) ? cur.flat() : [cur]
    );
  }, []);
};
```

### 2. 数组去重

```js
Array.prototype.unique = function(){
  return Array.from(new Set(this));
};
```

### 3. Array.filter

```js
Array.prototype.filter = function(callback, thisArg){
  thisArg = thisArg || this;
  const args = Array.from(this);
  const lens = args.length;
  const res = [];
  for(let i = 0;i < lens;i++){
    if(callback.call(thisArg, this[i], i, this)){
      res.push(this[i]);
    }
  }
  return res;
};
```

### 4. Array.map

```js
Array.prototype.map = function(callback, thisArg){
  thisArg = thisArg || this;
  const args = Array.from(this);
  const lens = args.length;
  const res = [];
  for(let i = 0;i < lens;i++){
    const item = callback.call(thisArg, this[i], i, this);
    res.push(item);
  }
  return res;
};
```

### 5. Array.reduce

```js
Array.prototype.reduce = function(callback, init, thisArg){
  thisArg = thisArg || this;
  const args = Array.from(this);
  const lens = args.length;
  let pre = init || args.length > 0 ? args[0] : []; // 没有传初始化的值，则第一个值为数组的第一个值
  for(let i = 0;i < lens;i++){
    pre = callback.call(thisArg, pre, this[i], i, this);
  }
  return pre;
};
```

### 6. Function.apply

```js
Function.prototype.apply = function(thisArg, args = []){
  const key = Symbol();
  thisArg[key] = this;
  const res = thisArg[key](...args);
  delete thisArg[key];
  return res;
};
```

### 7. Function.bind

```js
Function.prototype.bind = function(thisArg, ...args){
  return (...args2) => {
    const arg = [...args, ...args2];
    return this.apply(thisArg, arg);
  };
};
```

### 8.防抖

```js
const debundece = (callback) => {
  let timer;
  return function(...args) {
    const self = this;
    timer && clearTimeout(timer);
    timer = setTimeout(() => {
      callback.call(self, ...args);
    }, 2000);
  };
};
```

### 9.节流

```js
const throad = (callback) => {
  let isLock = false;
  let timer;
  return function(...args){
    if(isLock) return;
    const self = this
    isLock = true;
    timer = setTimeout(() => {
      callback.call(self,...args);
      isLock = false;
      clearTimeout(timer);
    }, 20);
  };
};
```

